#include <linux/module.h>
#include <linux/kernel.h>     
#include <linux/kthread.h>
#include <linux/module.h>     
#include <linux/stat.h>       
#include <linux/slab.h>       
#include <linux/capability.h> 
#include <linux/uaccess.h>    
#include <linux/compat.h>     
#include <linux/math64.h>     
#include <linux/err.h>        
#include <linux/delay.h>      
#include <linux/poll.h>       
#include <linux/vmalloc.h>    
#include <linux/fcntl.h>      
#include <linux/signal.h>     
#include <linux/types.h>      
#include <linux/workqueue.h>  
#include <asm/div64.h>
#include <asm/io.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h>

#define FC_READ_ADDR 	0x1020
#define FC_READ_STATUS	0x1024
#define FC_READ_DATA0	0x1028
#define FC_READ_DATA1	0x102C
#define FC_READ_DATA2	0x1030
#define FC_READ_DATA3	0x1034

static int opt_arg ;
#define SHOW_SECURITY_ENABLE		0
#define SHOW_PUBLIC_KEY			1
#define MAX_KEY_INDEX			17

static unsigned char bootromkey[MAX_KEY_INDEX + 1][513] = 
{
/*Customer key*/
"FROM CUSTOMER",

/*boor rom 0*/
"92547A03DA9F016B831ED542C202A607ECD24CB3D0E1361D4BE8E76A573D0F93C990806F0A33CED5D91F5BDAC31BC33D594BB6A6C54250C27CF7DEE5444F59C9BAE3F0ED62503425615B2B1A2E803103A6983D793C0736A1E78D9994833950F518FCAB8CF63F2E5F7E2061C21F5E780572DC2DE3ED63BB4FAD37C77A72E4D95B15E92E1DCD1D23FED61C7A2ACD0C9A618A2BDEC724F4539440AF6BBBAC4ACFBB88C08FB37E504CDE5BE2762CC1476F5EC09BF299CFF9EADAB8DC5450BA3FA15E0B0076323DD968C2F6A4CB6073D19640DFB0AB1F06AA02D4AAD7722E06D9659AF92A5CCD6EEC8B68B5FC3D5358E3586F5B330CB602867BEAAFDCDAAD738F0567\0",

/*boor rom 1*/
"9DE7A466C8CD8419BF329F73D42C62757B525FFADBC2633E7F1AE0D746487D70C8914F657725F2369CAB776BD28A840C59A3D7E310CB3B7C756B83EE7CE04DAEEAE2E7C74B0B87FAB7A1B3A7151B3E3F8B8487B88B72D3AA2AAA4E2F7D5A294AD1599CE3009746BBD754075F3321BBBC01C250CD3D30F63BDDE4F2D246B9A5D3329E26016024A5440FB6DEA60F9B23E85692ED2CC51791B675F6314842EAB94CA2D8F86794E9D06DB9C308B5FBD094C62544F3461C60400B5D9A3D5CB51E8FF091D509BEEF612BD83D0ABB7809AB2292B7C5028C6C80960E77CB1A7B2F337182BE1BF3E33C7A1F2CB786FFA48F49926AC323BC32BAF5EF231B23042C33662955\0",

/*boor rom 2*/
"DCAD7EA711C690E3AE61357203750D5C67E53F7B3382B3541A22137AE226F6572E6DF7905EB82414AE2E5D8772A3EE23D7EAE1C51253766CB78E48397695029D0EB59ACA9BE02D5A9CB3F976C279E418620B8AB885A1860C7E297C0E133E153325BE2E92FCFB26EF072043CB15F3F18BF4317E4B304BCBE825F9D385E927438047BE5AC0A07A14B1517C1916B9DDF61B080CF5D9CB67637F8619CD44629005F20D06DE5CBC11B2AA078E05050F16F04922A7AB9B98CB6CC8EBBBA3D449678616ACF1057905E99EC3CC8E3DF9603B07F660A00A0CF8462C415ABF78EF86760A9D40A6BA85398350BA1D7D182BEB2274202D4220B9A67718E6C87BD1D91D479C3F",

/*boor rom 3*/
"DCAD7EA711C690E3AE61357203750D5C67E53F7B3382B3541A22137AE226F6572E6DF7905EB82414AE2E5D8772A3EE23D7EAE1C51253766CB78E48397695029D0EB59ACA9BE02D5A9CB3F976C279E418620B8AB885A1860C7E297C0E133E153325BE2E92FCFB26EF072043CB15F3F18BF4317E4B304BCBE825F9D385E927438047BE5AC0A07A14B1517C1916B9DDF61B080CF5D9CB67637F8619CD44629005F20D06DE5CBC11B2AA078E05050F16F04922A7AB9B98CB6CC8EBBBA3D449678616ACF1057905E99EC3CC8E3DF9603B07F660A00A0CF8462C415ABF78EF86760A9D40A6BA85398350BA1D7D182BEB2274202D4220B9A67718E6C87BD1D91D479C3F",

/*boor rom 4*/
"861C36C1A7AAAED5188E1F98CEF1115CA4F69920D9BD75CA1628FE1B1E8425689A410228AC47E47A66A8B08B8361A1E709604B87534031D07CCB3C50978928AED80B3442CDA09404DAEC47F6E1B0D9BD769B955BA611620DC9C667626FB343F0661E4B5C730B9794D1D96142391AE0357D6B96C645FC5BA5F59DA132DEF147F78198C3C3A52A2BBEFA382EDF3A261E106371AA5D21DC7E61F5FEF42776F9E381BFB8279593321DE1FD88A18805348CF1DDFBFA2A81EFFC3B95E4CBA4BFAEF4A9DB42F14CDCF6F312485DEFC31F3925B024A471847327E1B5EAF6413DABF0027C5280104C77CC6254538DAA5A273DD461E4DB405912F8E7354221DB99FCDDFB03",

/*boor rom 5*/
"BEDC76AF8BB9E6153510C6835E82FF84277300B161BBEB41493B47B34AD2D9231E7C4EB20078D33F6D9E0952500EB9569A15CD3F5451902F2F1BFC6AA11EF1A3AC239D09E8DE14D77211FE02071799661574662BB5F6F4E3A2D097BB9AAED88AD309C558A2DC7582EA74639CD7818B2D328CC03C97F8F34E0352E82C2123E8709E78A18A43CDB1CCD048C1B27EDE3553566D0E30D6BF350117B26314B093F04CE58659E515D21A997DDC11BBE09D65132390E46B5F1F5E1B9AA3D0E8E2A2545FC138BCA47B8EAFC32C3EDF5EE851CDE0EDF3E33AF22D9B43EFD43E04968EDA65F52D93123F6DD85E191455BC40B07D0A556DA6BB83F24E433BF82196D3A057AD",


/*boor rom 6*/
"B6F11B8C999B71E77017F9A037B0D87F422A34781C4090AF1B6CBEFD75F14410C6065B44410FEBE7E951DC0C653D8BC455E1D2C66970D0AF7072C78FE7DDDF3DD5FA8C295F135391DF0083DEE08CDD1CE0FBB3210C2424183AC43DF03276891B999F80DA7C3A20373F5933495E8CA0CD06083C9C3AB56B9A4A7532CB468AC7FCFABB519F7905839F3E04AC118FDBF687708665107CBF034EDED8BD508218FEA25F64343932985AB9E5603D84902F3FFEDAE34E3990F701078C74C0B7060A594E10E8B1D7BB9B4ACD34D0BE6BDF594E44B8F86436330F5DB9689E2DA0F3B096D2F056B00E140870B49E7A87E6322F7E9567F2D9686C39BB86CDC010A3EFD45277",

/*boor rom 7*/
"B41DC41193BC16FD2BAC1295841458D3391CA36BE8B98F00E6A17F21B0E8133D80E55F18C145C53540D4E0757831EABE0CA08FC38A0ADB102AEA6EF7C93509BE37C58D3BDA194A6D7C33DBD41CA01F90052C2ADB3DB66CADE0EB521FFF37BEF514D0EE4A50A8E7561CC1EAA64CB9E246AF77A902086E39066B733D07B25B12BA58C7AEB8E963080678C7DC2C8EE2940A9FE13923130A90424526B5001707058E2E40BF566BB8EB8246AA0966702A298E1C1DC85A78AEBCAAA61E7594082075BC4C4B44A14D099AB7C12C839EBE60E0A1D359632AD426E7BE2A2AF6CB2D3FEFD380D64BD08830562B55142B58CDA57D3EF0E4F1C170DEEB3AAB99DF4E66D2A53B",

/*boor rom 8*/
"AD0BFCEA484F0AE9BA91CB503920E86542DD91F005391A840DB1E28D3E5BCACC72B03651D823CAD9D78C4D914AAF7A96654CCDCF07CFE7CE563742780CEFF95179BF877CEFA145B854D29DAA29DED186C536112435BA068237EACED7B5B388B350A86198F7616EDD2A09744CD158B4D99FFD396D407AE3F85BAB2785D97B1A12800F84A82BAE3417164633E440D33846F8012D886DBE9BDE12DF75E30C85E30F299EDB378FED4551F10100504A5790C1292876B487F53678344701BD883DA17DE2F2930CD91024C37030839D6D491DEDD80D606E4EF404C818D6C13FE0FB5AFDDC885FA5336CD1ABE0BF8497C4C06B04B8C0644D6EAF0ABC05C10226D13F1345",

/*boor rom 9*/
"BB8C6E491BEEB0759D3BEC8DEDF79F66CDA05E0FD8065F488AA2DB878E5845BDED1B64B29BBB1A3E0BA17C5D21F3447C05DA2CF6169300D285DD5194A23095E063067FD6090ED45F9AE3395123EC477482FCA8232A4B873125604177EBC15FE4CF3A06AC0958552374A690AE0C571E4FD7816634C4FA169EE533CE2AB96AB0C64B3933DBA991FF212C504CA104EFC71288CEFCEA275D031DD3F0E14E19986EB47DDAB9D078648E71C7814CA673870CE7204F86C3BF5520A26D224A612F1135B0B9A790B4CEB0261EE03EC80BCC2A0A686946D84FC14AFC3ABBAB5A2EF0F46ED608522B41462705130098D13C108040E430766ABF68DC8D3519EB7B20B77F3B37",

/*boor rom a*/
"86C6AF893AADCBBB3E2600A76CDB2DA7326B27279F0BB388E8EED2DFB84D6C0BEE44B08C7356566AD73B8B9406D451C8C39B2E0859BE96C7021D2028025B4882068737FB189AF99343E09CDC99B839C013A905CB8896905414DFC16324677E2663FA3418BF6317D3E80AEE3138AD3F240864C81690BEEEF8238941CE69E80531BDE8AA16617569CCFFAE44F68F7F52E1E0700A8B90A6AB00B0484D24DE7A55A4E5787A89D4D345961C2EB0A89ED1C4E72B2CBF63E21F4C3CCCF9EC7A98B343F1315985B1D3150948DEC1E73BBD28C5D43C24A2D2992D3CB32501947D4A34A7D3CBD7744EC5E583265F37921385666ECD63F5CC1EA7A86A027F6AA9692B1A52FF",

/*boor rom b*/
"91AA080618C1AEB37D024D9A52F6735FAFF6C0875BF268AE5518BCA98D94EAA39EA7B0E2F1A17F9475C7BA20801746B1028A2ADFA518A4D1D883137CE8020888F04DBB0ADEAC99B2D72B9AD8B72853C5A4F28DB1E738605436CABB2578C5FF3085871630061E5F62EF7FADE51C83200AA88AA168453370E3D440A0560A4E840DD96D5F801CCA9702D3108CC1D0ECC808F2C66825553EF790B4FBBEAF7BC5155B5A90850F6124D4ADD759073547290FCA1E2294F468444E4EB801F5CF57AD7424E25A8870D2AAD42C87234E69210AD67E83FDA278E4BD47F6D3EB817267EDE3EF4203C9EB47813BE4E168A738E2C548FE51F59C7DBDB188AA6D04F96E07287D0D",

/*boor rom c*/
"CB99143C52AC5A0D0CA797D346F65F41CFCA73A43253327A62A249587B3BFC16694B3BFCFE4CF733A2C8DE1C63E499167BA0AB92C302ED62CB9576BFB3D9ACE2FDB268C9E64200B22274C2AAC0738528F24DC29D52F742524796ABE775C700FFE7C6C9E382A2B2C6941A0B2CF21EDECABCAB8189B53A47D7D3356965D1B261218A7ABD5C475A98C4EDE62FE6154CE556C9BAEB7760C41B23C80905489CDA277432A07B0CEE156648EC572FF369E5290DEA55E7531E88B8257516E606A4C07604C28877D668E713387EE89F3D682AD7ED35A7BBDB5D1AF944B873C0E0D756E899F5691C6872C8F670D1A3F0DC5E27FD7A78ECF4C482DAD54333D228E717BB7665",

/*boor rom d*/
"8BBDA5C6B237C185D1B09089261146EE3F603757C088D68A80E94E117FCE3E512607BCF755706D7A3C987EE3D104F9F6A5FA41FDCB1C1DDA77C37ADADBC73DA6139A2FAC95A84C85CF23541C3EF7AF27588E9C368890E40C7563EF532D64F3BD9B0CA33D5F96AD55D53752A38154521E26E508617CF0C87882EC6B8057FC0989E33C1555D74D6DFBCFE9351362DA01EF9A19356BE40D59823A0319F4557766E36F98C361DFE04753DF79533E7771008AD6C6A49808C28DD623F0DBC4920BE589201E60A2012D6507B2B31E2E66B5B9829C502671DFA5710D8E8AED419A2BD3B08B82730C81847DAD6AD4EEAB7793EACA5BBAA4D3CE5EE44E519B02DB11F9252B",

/*boor rom e*/
"9CC6FF4EC1BBD898545093EC2C209BF9D368F37B8717591E370F2A00600D5857B670C6A60B447D1A6F558C817E5DED2F3042E2EEA21AA360311BCE13685DC40BBFCFA8967AECC92BF8AEFC5782D4ED3E3A042CC155908E472F0693F0F8ED2BAC54E9F3FC054F4B4FE9FAA2B4848A623D7141DAD98B6A2C54A5CE445A1C8E8C15A33B2B61EA52F7906AAB3EE406D4742CDEC2D6A06288EE7059C4AC2F451C3EAFBA57A2C344AAAC09A56319EB781149E464FCE72B8E1288704B2BE57D1F80D53919AAA124EAF6D47DF62E256632EF639AFDA0D0DDEE3E85FBD75A2BA544E86D60C930F2BEBA122B82A67C9E76EB0596250D17644AD2BC77383B6251A51997C1CF",

/*boor rom f*/
"ABE4278565AFEC59429E329D1BB0F3C23BB810F828B02D3EEBA55C46A1E354EC1D7F0865AAA11EB7C47C3237B422D59DF27480FC36DF07834E123ACB67A7C5E42CAAF17B019EA9546D8B7453B12F068B96BFA0E51019377A01DA0D48DFFFA7BEFE8A7C82EDD63CBB5FE6A83F6EF285C6FE112C1EE546C587BFBF40B2F173BD4F379E2931DBF42CAC01D8670F632A3FFC555D6506E2F173ECD373EF926841A352CB66D8B9DEEB118F6BD43A7553A25494975351413DA14687E7AAC0FFB1CE6AAA4F72652734996CB1AEFE0B093D2ABC0B0AE33843F9717EB25EB35DE0F48C9910B4A8A35ABD4243037AD169931973713AF42115517E0D9C28527FEC1161F914D5",

"Invalid"
};

/** read fuse data from data-addr register
 *@param bQuadWord 0: one word to be read out; 1: 4 words to be read out
 */
int read_fuse(unsigned int fuseOffset, unsigned int bQuadWord, unsigned int* buf)
{
    int addr_reg;
    int temp;
    // setup addr_reg for read command
    addr_reg = 0xC2000000 | // set interlock to 0xC2 to indicate the start of read operation
            (fuseOffset & 0x0000FFFF); // set fuse offset to addr
    // loop until read is successful
    do
    {
        // initiate read command
        do
        {
            // wait for read interface to be idle
            while ( (TURING_READL(FC_READ_ADDR)&0xFF000000) != 0x00000000);
            // attempt read, then check if command was accepted
            // i.e. busy, done or invalid
            TURING_WRITEL(addr_reg,FC_READ_ADDR);
            temp = TURING_READL(FC_READ_STATUS);
            // exit if read had an error and return temp
            if (temp & 0x000000A0) 
                return temp;
         }while (!(temp&0x11));  // loop again if busy or done bits are not active

        // wait for read to complete
        while (!(temp&0x00000010)) 
        {
            temp = TURING_READL(FC_READ_STATUS);
        }
        if (temp & 0x000000A0)
            return temp;
        
        // copy word to data array
        buf[0] = TURING_READL(FC_READ_DATA0);
        // copy three more words if performing 128-bit read
        if (bQuadWord)
        {
            buf[1] = TURING_READL(FC_READ_DATA1);
            buf[2] = TURING_READL(FC_READ_DATA2);
            buf[3] = TURING_READL(FC_READ_DATA3);
        }
        // check done bit one more time
        // if it is still set then the correct data was read from the registers
        // if it is not set then another clientâ€™s data may have overwritten
        // data in the registers before they were read
    }while(0==(TURING_READL(FC_READ_STATUS)&0x10));

    return 0;
}
static unsigned char customer_key[256] __attribute__((aligned (4)));

static void get_opt_key(unsigned int *buf)
{
	int i,j;
	unsigned long otp_rsa_key_off = 0x290; 
	for(i=0,j=0; i<64; i+=4,j+=16)
	{
		read_fuse(otp_rsa_key_off+j ,1, buf+i);
	}
	return;
}
static int sx6_security_proc_show(struct seq_file *m, void *v) 
{
	unsigned int security_otp,key_index;
	unsigned long val,i;
	unsigned char *p = bootromkey[0];

	val = TURING_READL(TURING_FC_2);
	security_otp = (val&0x2)?1:0;

	if(security_otp)
		key_index = (val>>2)&0xf;
	else 
		key_index = MAX_KEY_INDEX;

	if(key_index)
		key_index = key_index < MAX_KEY_INDEX? key_index : MAX_KEY_INDEX ;
	else
	{
 	  	// use customer's key
		get_opt_key((unsigned int*)customer_key);
		 for(i=0; i<256; i++)
		{
 	  		snprintf(p,3,"%02X",customer_key[i]);
			p += 2;
		}
		p[512] = '\0';	
	}
	if(opt_arg == SHOW_SECURITY_ENABLE)	
		seq_printf(m, "%d\n", security_otp);
	else if(opt_arg == SHOW_PUBLIC_KEY)
		seq_printf(m, "%s\n", bootromkey[key_index]);
	return 0;	
}

static int secure_opt_open(struct inode *inode, struct file *file)
{	
	opt_arg = SHOW_SECURITY_ENABLE;
	return single_open(file, sx6_security_proc_show, NULL);
}

static int public_key_open(struct inode *inode, struct file *file)
{
	opt_arg = SHOW_PUBLIC_KEY;
	return single_open(file, sx6_security_proc_show, NULL);
}
 
static const struct file_operations secure_opt_ops = {
        .open           = secure_opt_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};

static const struct file_operations public_key_ops = {
        .open           = public_key_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = seq_release,
};

/*
 * Called by secure_check_init() to initialize the /proc/security subtree
 */
static void proc_security_init(void)
{
	if (!proc_mkdir("security", NULL))          
		return;

	proc_create("security/security_boot",0,NULL,&secure_opt_ops);
	proc_create("security/bootromkey",0,NULL,&public_key_ops);
}
